{"ast":null,"code":"import extractBrush from \"./extractBrush\";\nimport extractOpacity from \"./extractOpacity\";\nimport { strokeProps } from \"../props\";\nimport extractLengthList from \"./extractLengthList\";\nvar caps = {\n  butt: 0,\n  square: 2,\n  round: 1\n};\nvar joins = {\n  miter: 0,\n  bevel: 2,\n  round: 1\n};\nvar strokeKeys = Object.keys(strokeProps);\nexport default function (props, styleProperties) {\n  strokeKeys.forEach(function (name) {\n    if (props.hasOwnProperty(name)) {\n      styleProperties.push(name);\n    }\n  });\n  var stroke = props.stroke;\n  var strokeWidth = props.strokeWidth,\n      strokeDasharray = props.strokeDasharray;\n\n  if (!strokeDasharray || strokeDasharray === \"none\") {\n    strokeDasharray = null;\n  } else {\n    strokeDasharray = extractLengthList(strokeDasharray);\n\n    if (strokeDasharray && strokeDasharray.length % 2 === 1) {\n      strokeDasharray = strokeDasharray.concat(strokeDasharray);\n    }\n  }\n\n  if (!strokeWidth || typeof strokeWidth !== \"string\") {\n    strokeWidth = \"\" + (strokeWidth || 1);\n  }\n\n  return {\n    stroke: extractBrush(stroke),\n    strokeOpacity: extractOpacity(props.strokeOpacity),\n    strokeLinecap: caps[props.strokeLinecap] || 0,\n    strokeLinejoin: joins[props.strokeLinejoin] || 0,\n    strokeDasharray: strokeDasharray,\n    strokeWidth: strokeWidth,\n    strokeDashoffset: strokeDasharray ? +props.strokeDashoffset || 0 : null,\n    strokeMiterlimit: parseFloat(props.strokeMiterlimit) || 4\n  };\n}","map":{"version":3,"sources":["/Users/xpyx/Code/projects/solita-academy-2021/solitaFrontend/node_modules/react-native-svg/lib/extract/extractStroke.js"],"names":["extractBrush","extractOpacity","strokeProps","extractLengthList","caps","butt","square","round","joins","miter","bevel","strokeKeys","Object","keys","props","styleProperties","forEach","name","hasOwnProperty","push","stroke","strokeWidth","strokeDasharray","length","concat","strokeOpacity","strokeLinecap","strokeLinejoin","strokeDashoffset","strokeMiterlimit","parseFloat"],"mappings":"AAAA,OAAOA,YAAP;AACA,OAAOC,cAAP;AACA,SAASC,WAAT;AACA,OAAOC,iBAAP;AAEA,IAAMC,IAAI,GAAG;AACTC,EAAAA,IAAI,EAAE,CADG;AAETC,EAAAA,MAAM,EAAE,CAFC;AAGTC,EAAAA,KAAK,EAAE;AAHE,CAAb;AAMA,IAAMC,KAAK,GAAG;AACVC,EAAAA,KAAK,EAAE,CADG;AAEVC,EAAAA,KAAK,EAAE,CAFG;AAGVH,EAAAA,KAAK,EAAE;AAHG,CAAd;AAMA,IAAMI,UAAU,GAAGC,MAAM,CAACC,IAAP,CAAYX,WAAZ,CAAnB;AAEA,eAAe,UAASY,KAAT,EAAgBC,eAAhB,EAAiC;AAC5CJ,EAAAA,UAAU,CAACK,OAAX,CAAmB,UAAAC,IAAI,EAAI;AACvB,QAAIH,KAAK,CAACI,cAAN,CAAqBD,IAArB,CAAJ,EAAgC;AAC5BF,MAAAA,eAAe,CAACI,IAAhB,CAAqBF,IAArB;AACH;AACJ,GAJD;AAD4C,MAOpCG,MAPoC,GAOzBN,KAPyB,CAOpCM,MAPoC;AAAA,MAQtCC,WARsC,GAQLP,KARK,CAQtCO,WARsC;AAAA,MAQzBC,eARyB,GAQLR,KARK,CAQzBQ,eARyB;;AAU5C,MAAI,CAACA,eAAD,IAAoBA,eAAe,KAAK,MAA5C,EAAoD;AAChDA,IAAAA,eAAe,GAAG,IAAlB;AACH,GAFD,MAEO;AAKHA,IAAAA,eAAe,GAAGnB,iBAAiB,CAACmB,eAAD,CAAnC;;AACA,QAAIA,eAAe,IAAIA,eAAe,CAACC,MAAhB,GAAyB,CAAzB,KAA+B,CAAtD,EAAyD;AACrDD,MAAAA,eAAe,GAAGA,eAAe,CAACE,MAAhB,CAAuBF,eAAvB,CAAlB;AACH;AACJ;;AAED,MAAI,CAACD,WAAD,IAAgB,OAAOA,WAAP,KAAuB,QAA3C,EAAqD;AACjDA,IAAAA,WAAW,SAAMA,WAAW,IAAI,CAArB,CAAX;AACH;;AAED,SAAO;AACHD,IAAAA,MAAM,EAAEpB,YAAY,CAACoB,MAAD,CADjB;AAEHK,IAAAA,aAAa,EAAExB,cAAc,CAACa,KAAK,CAACW,aAAP,CAF1B;AAGHC,IAAAA,aAAa,EAAEtB,IAAI,CAACU,KAAK,CAACY,aAAP,CAAJ,IAA6B,CAHzC;AAIHC,IAAAA,cAAc,EAAEnB,KAAK,CAACM,KAAK,CAACa,cAAP,CAAL,IAA+B,CAJ5C;AAKHL,IAAAA,eAAe,EAAEA,eALd;AAMHD,IAAAA,WAAW,EAAEA,WANV;AAOHO,IAAAA,gBAAgB,EAAEN,eAAe,GAAG,CAACR,KAAK,CAACc,gBAAP,IAA2B,CAA9B,GAAkC,IAPhE;AAQHC,IAAAA,gBAAgB,EAAEC,UAAU,CAAChB,KAAK,CAACe,gBAAP,CAAV,IAAsC;AARrD,GAAP;AAUH","sourcesContent":["import extractBrush from \"./extractBrush\";\nimport extractOpacity from \"./extractOpacity\";\nimport { strokeProps } from \"../props\";\nimport extractLengthList from \"./extractLengthList\";\n\nconst caps = {\n    butt: 0,\n    square: 2,\n    round: 1,\n};\n\nconst joins = {\n    miter: 0,\n    bevel: 2,\n    round: 1,\n};\n\nconst strokeKeys = Object.keys(strokeProps);\n\nexport default function(props, styleProperties) {\n    strokeKeys.forEach(name => {\n        if (props.hasOwnProperty(name)) {\n            styleProperties.push(name);\n        }\n    });\n\n    const { stroke } = props;\n    let { strokeWidth, strokeDasharray } = props;\n\n    if (!strokeDasharray || strokeDasharray === \"none\") {\n        strokeDasharray = null;\n    } else {\n        // <dasharray> It's a list of comma and/or white space separated <length>s\n        // and <percentage>s that specify the lengths of alternating dashes and gaps.\n        // If an odd number of values is provided, then the list of values is repeated\n        // to yield an even number of values. Thus, 5,3,2 is equivalent to 5,3,2,5,3,2.\n        strokeDasharray = extractLengthList(strokeDasharray);\n        if (strokeDasharray && strokeDasharray.length % 2 === 1) {\n            strokeDasharray = strokeDasharray.concat(strokeDasharray);\n        }\n    }\n\n    if (!strokeWidth || typeof strokeWidth !== \"string\") {\n        strokeWidth = `${strokeWidth || 1}`;\n    }\n\n    return {\n        stroke: extractBrush(stroke),\n        strokeOpacity: extractOpacity(props.strokeOpacity),\n        strokeLinecap: caps[props.strokeLinecap] || 0,\n        strokeLinejoin: joins[props.strokeLinejoin] || 0,\n        strokeDasharray: strokeDasharray,\n        strokeWidth: strokeWidth,\n        strokeDashoffset: strokeDasharray ? +props.strokeDashoffset || 0 : null,\n        strokeMiterlimit: parseFloat(props.strokeMiterlimit) || 4,\n    };\n}\n"]},"metadata":{},"sourceType":"module"}
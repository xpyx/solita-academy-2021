{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport { Children } from \"react\";\nimport _ from \"lodash\";\nimport Color from \"color\";\nimport extractOpacity from \"./extractOpacity\";\nimport extractTransform from \"./extractTransform\";\nimport units from \"../units\";\nvar percentReg = /^([+\\-]?\\d+(?:\\.\\d+)?(?:[eE][+\\-]?\\d+)?)(%?)$/;\n\nfunction percentToFloat(percent) {\n  var matched = percent.match(percentReg);\n\n  if (!matched) {\n    console.warn(\"`\" + percent + \"` is not a valid number or percentage string.\");\n    return 0;\n  }\n\n  return matched[2] ? matched[1] / 100 : +matched[1];\n}\n\nexport default function (props) {\n  if (!props.id) {\n    return null;\n  }\n\n  var stops = {};\n  Children.forEach(props.children, function (child) {\n    if (child.props.stopColor && child.props.offset) {\n      var offset = percentToFloat(child.props.offset);\n      stops[offset] = Color(child.props.stopColor).alpha(extractOpacity(child.props.stopOpacity));\n    }\n  });\n\n  var sorted = _.sortBy(_.map(stops, function (stop, offset) {\n    return {\n      stop: stop,\n      offset: offset\n    };\n  }), \"offset\");\n\n  var gradient = [];\n  sorted.forEach(function (_ref) {\n    var stop = _ref.stop;\n\n    var _stop$rgb$array = stop.rgb().array(),\n        _stop$rgb$array2 = _slicedToArray(_stop$rgb$array, 4),\n        r = _stop$rgb$array2[0],\n        g = _stop$rgb$array2[1],\n        b = _stop$rgb$array2[2],\n        _stop$rgb$array2$ = _stop$rgb$array2[3],\n        a = _stop$rgb$array2$ === void 0 ? 1 : _stop$rgb$array2$;\n\n    gradient.push(r / 255);\n    gradient.push(g / 255);\n    gradient.push(b / 255);\n    gradient.push(a);\n  });\n  gradient.push.apply(gradient, _toConsumableArray(sorted.map(function (_ref2) {\n    var offset = _ref2.offset;\n    return +offset;\n  })));\n  var gradientTransform;\n\n  if (props.gradientTransform) {\n    gradientTransform = extractTransform(props.gradientTransform);\n  } else if (props.transform) {\n    gradientTransform = extractTransform(props.transform);\n  } else {\n    gradientTransform = extractTransform(props);\n  }\n\n  return {\n    gradient: gradient,\n    name: props.id,\n    gradientTransform: gradientTransform,\n    gradientUnits: units[props.gradientUnits] || 0\n  };\n}","map":{"version":3,"sources":["/Users/xpyx/Code/projects/solita-academy-2021/solitaFrontend/node_modules/react-native-svg/lib/extract/extractGradient.js"],"names":["Children","_","Color","extractOpacity","extractTransform","units","percentReg","percentToFloat","percent","matched","match","console","warn","props","id","stops","forEach","children","child","stopColor","offset","alpha","stopOpacity","sorted","sortBy","map","stop","gradient","rgb","array","r","g","b","a","push","gradientTransform","transform","name","gradientUnits"],"mappings":"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","sourcesContent":["import { Children } from \"react\";\nimport _ from \"lodash\";\nimport Color from \"color\";\n\nimport extractOpacity from \"./extractOpacity\";\nimport extractTransform from \"./extractTransform\";\nimport units from \"../units\";\n\nconst percentReg = /^([+\\-]?\\d+(?:\\.\\d+)?(?:[eE][+\\-]?\\d+)?)(%?)$/;\n\nfunction percentToFloat(percent) {\n    const matched = percent.match(percentReg);\n    if (!matched) {\n        console.warn(\n            `\\`${percent}\\` is not a valid number or percentage string.`,\n        );\n        return 0;\n    }\n\n    return matched[2] ? matched[1] / 100 : +matched[1];\n}\n\nexport default function(props) {\n    if (!props.id) {\n        return null;\n    }\n\n    const stops = {};\n    Children.forEach(props.children, child => {\n        if (child.props.stopColor && child.props.offset) {\n            // convert percent to float.\n            const offset = percentToFloat(child.props.offset);\n\n            // add stop\n            //noinspection JSUnresolvedFunction\n            stops[offset] = Color(child.props.stopColor).alpha(\n                extractOpacity(child.props.stopOpacity),\n            );\n        }\n    });\n\n    const sorted = _.sortBy(\n        _.map(stops, (stop, offset) => {\n            return { stop, offset };\n        }),\n        \"offset\",\n    );\n\n    const gradient = [];\n\n    sorted.forEach(({ stop }) => {\n        const [r, g, b, a = 1] = stop.rgb().array();\n        gradient.push(r / 255);\n        gradient.push(g / 255);\n        gradient.push(b / 255);\n        gradient.push(a);\n    });\n\n    gradient.push(...sorted.map(({ offset }) => +offset));\n\n    let gradientTransform;\n    if (props.gradientTransform) {\n        gradientTransform = extractTransform(props.gradientTransform);\n    } else if (props.transform) {\n        gradientTransform = extractTransform(props.transform);\n    } else {\n        gradientTransform = extractTransform(props);\n    }\n\n    return {\n        gradient,\n        name: props.id,\n        gradientTransform,\n        gradientUnits: units[props.gradientUnits] || 0,\n    };\n}\n"]},"metadata":{},"sourceType":"module"}
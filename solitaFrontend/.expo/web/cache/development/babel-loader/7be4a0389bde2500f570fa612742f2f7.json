{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport Matrix2D from \"../Matrix2D\";\nimport peg from \"pegjs\";\nimport _ from \"lodash\";\nvar pooledMatrix = new Matrix2D();\n\nfunction transformToMatrix(props, transform) {\n  pooledMatrix.reset();\n  appendTransform(props);\n\n  if (transform) {\n    appendTransform(transform);\n  }\n\n  return pooledMatrix.toArray();\n}\n\nvar transformParser = peg.generate(\"\\n{\\n    var deg2rad = Math.PI / 180;\\n\\n    /*\\n     \\u2554\\u2550        \\u2550\\u2557   \\u2554\\u2550        \\u2550\\u2557   \\u2554\\u2550     \\u2550\\u2557\\n     \\u2551 al cl el \\u2551   \\u2551 ar cr er \\u2551   \\u2551 a c e \\u2551\\n     \\u2551 bl dl fl \\u2551 * \\u2551 br dr fr \\u2551 = \\u2551 b d f \\u2551\\n     \\u2551 0  0  1  \\u2551   \\u2551 0  0  1  \\u2551   \\u2551 0 0 1 \\u2551\\n     \\u255A\\u2550        \\u2550\\u255D   \\u255A\\u2550        \\u2550\\u255D   \\u255A\\u2550     \\u2550\\u255D\\n    */\\n    function multiply_matrices(l, r) {\\n        var [al, cl, el, bl, dl, fl] = l;\\n        var [ar, cr, er, br, dr, fr] = r;\\n\\n        var a = al * ar + cl * br;\\n        var c = al * cr + cl * dr;\\n        var e = al * er + cl * fr + el;\\n        var b = bl * ar + dl * br;\\n        var d = bl * cr + dl * dr;\\n        var f = bl * er + dl * fr + fl;\\n\\n        return [a, c, e, b, d, f];\\n    }\\n}\\n\\ntransformList\\n    = wsp* ts:transforms? wsp* { return ts; }\\n\\ntransforms\\n    = t:transform commaWsp* ts:transforms\\n    {\\n        return multiply_matrices(t, ts);\\n    }\\n    / t:transform\\n\\ntransform\\n    = matrix\\n    / translate\\n    / scale\\n    / rotate\\n    / skewX\\n    / skewY\\n\\nmatrix\\n    = \\\"matrix\\\" wsp* \\\"(\\\" wsp*\\n        a:number commaWsp\\n        b:number commaWsp\\n        c:number commaWsp\\n        d:number commaWsp\\n        e:number commaWsp\\n        f:number wsp* \\\")\\\"\\n    {\\n        return [\\n            a, c, e,\\n            b, d, f\\n        ];\\n    }\\n\\ntranslate\\n    = \\\"translate\\\" wsp* \\\"(\\\" wsp* tx:number ty:commaWspNumber? wsp* \\\")\\\"\\n    {\\n        return [\\n            1, 0, tx,\\n            0, 1, ty || 0\\n        ];\\n    }\\n\\nscale\\n    = \\\"scale\\\" wsp* \\\"(\\\" wsp* sx:number sy:commaWspNumber? wsp* \\\")\\\"\\n    {\\n        return [\\n            sx, 0,                     0,\\n            0,  sy === null ? sx : sy, 0\\n        ];\\n    }\\n\\nrotate\\n    = \\\"rotate\\\" wsp* \\\"(\\\" wsp* angle:number c:commaWspTwoNumbers? wsp* \\\")\\\"\\n    {\\n        var cos = Math.cos(deg2rad * angle);\\n        var sin = Math.sin(deg2rad * angle);\\n        if (c !== null) {\\n            var [x, y] = c;\\n            return [\\n                cos, -sin, cos * -x + -sin * -y + x,\\n                sin,  cos, sin * -x +  cos * -y + y\\n            ];\\n        }\\n        return [\\n            cos, -sin, 0,\\n            sin,  cos, 0\\n        ];\\n    }\\n\\nskewX\\n    = \\\"skewX\\\" wsp* \\\"(\\\" wsp* angle:number wsp* \\\")\\\"\\n    {\\n        return [\\n            1, Math.tan(deg2rad * angle), 0,\\n            0, 1,                         0\\n        ];\\n    }\\n\\nskewY\\n    = \\\"skewY\\\" wsp* \\\"(\\\" wsp* angle:number wsp* \\\")\\\"\\n    {\\n        return [\\n            1,                         0, 0,\\n            Math.tan(deg2rad * angle), 1, 0\\n        ];\\n    }\\n\\nnumber\\n    = f:(sign? floatingPointConstant) { return parseFloat(f.join(\\\"\\\")); }\\n    / i:(sign? integerConstant) { return parseInt(i.join(\\\"\\\")); }\\n\\ncommaWspNumber\\n    = commaWsp n:number { return n; }\\n\\ncommaWspTwoNumbers\\n    = commaWsp n1:number commaWsp n2:number { return [n1, n2]; }\\n\\ncommaWsp\\n    = (wsp+ comma? wsp*) / (comma wsp*)\\n\\ncomma\\n    = \\\",\\\"\\n\\nintegerConstant\\n    = ds:digitSequence { return ds.join(\\\"\\\"); }\\n\\nfloatingPointConstant\\n    = f:(fractionalConstant exponent?) { return f.join(\\\"\\\"); }\\n    / d:(digitSequence exponent) { return d.join(\\\"\\\"); }\\n\\nfractionalConstant \\\"fractionalConstant\\\"\\n    = d1:digitSequence? \\\".\\\" d2:digitSequence { return [d1 ? d1.join(\\\"\\\") : null, \\\".\\\", d2.join(\\\"\\\")].join(\\\"\\\"); }\\n    / d:digitSequence \\\".\\\" { return d.join(\\\"\\\"); }\\n\\nexponent\\n    =  e:([eE] sign? digitSequence) { return [e[0], e[1], e[2].join(\\\"\\\")].join(\\\"\\\"); }\\n\\nsign\\n    = [+-]\\n\\ndigitSequence\\n    = digit+\\n\\ndigit\\n    = [0-9]\\n\\nwsp\\n    = [\\\\u0020\\\\u0009\\\\u000D\\\\u000A]\\n\");\n\nfunction appendTransform(transform) {\n  if (transform) {\n    if (typeof transform === \"string\") {\n      try {\n        var _transformParser$pars = transformParser.parse(transform),\n            _transformParser$pars2 = _slicedToArray(_transformParser$pars, 6),\n            a = _transformParser$pars2[0],\n            c = _transformParser$pars2[1],\n            e = _transformParser$pars2[2],\n            b = _transformParser$pars2[3],\n            d = _transformParser$pars2[4],\n            f = _transformParser$pars2[5];\n\n        pooledMatrix.append.apply(pooledMatrix, [a, b, c, d, e, f]);\n      } catch (e) {\n        console.error(e);\n      }\n    } else {\n      pooledMatrix.appendTransform(transform.x + transform.originX, transform.y + transform.originY, transform.scaleX, transform.scaleY, transform.rotation, transform.skewX, transform.skewY, transform.originX, transform.originY);\n    }\n  }\n}\n\nfunction universal2axis(universal, axisX, axisY, defaultValue) {\n  var coords = [];\n  var x;\n  var y;\n\n  if (_.isString(universal)) {\n    coords = universal.split(/\\s*,\\s*/);\n\n    if (coords.length === 2) {\n      x = +coords[0];\n      y = +coords[1];\n    } else if (coords.length === 1) {\n      x = y = +coords[0];\n    }\n  } else if (_.isNumber(universal)) {\n    x = y = universal;\n  }\n\n  axisX = +axisX;\n\n  if (!isNaN(axisX)) {\n    x = axisX;\n  }\n\n  axisY = +axisY;\n\n  if (!isNaN(axisY)) {\n    y = axisY;\n  }\n\n  return [x || defaultValue || 0, y || defaultValue || 0];\n}\n\nexport function props2transform(props) {\n  if (props && typeof props === \"string\") {\n    return props;\n  }\n\n  var _universal2axis = universal2axis(props.origin, props.originX, props.originY),\n      _universal2axis2 = _slicedToArray(_universal2axis, 2),\n      originX = _universal2axis2[0],\n      originY = _universal2axis2[1];\n\n  var _universal2axis3 = universal2axis(props.scale, props.scaleX, props.scaleY, 1),\n      _universal2axis4 = _slicedToArray(_universal2axis3, 2),\n      scaleX = _universal2axis4[0],\n      scaleY = _universal2axis4[1];\n\n  var _universal2axis5 = universal2axis(props.skew, props.skewX, props.skewY),\n      _universal2axis6 = _slicedToArray(_universal2axis5, 2),\n      skewX = _universal2axis6[0],\n      skewY = _universal2axis6[1];\n\n  var _universal2axis7 = universal2axis(props.translate, _.isNil(props.translateX) ? props.x || 0 : props.translateX, _.isNil(props.translateY) ? props.y || 0 : props.translateY),\n      _universal2axis8 = _slicedToArray(_universal2axis7, 2),\n      translateX = _universal2axis8[0],\n      translateY = _universal2axis8[1];\n\n  return {\n    rotation: +props.rotation || 0,\n    scaleX: scaleX,\n    scaleY: scaleY,\n    originX: originX,\n    originY: originY,\n    skewX: skewX,\n    skewY: skewY,\n    x: translateX,\n    y: translateY\n  };\n}\nexport default function (props) {\n  return transformToMatrix(props2transform(props), props.transform ? props2transform(props.transform) : null);\n}","map":{"version":3,"sources":["/Users/xpyx/Code/projects/solita-academy-2021/solitaFrontend/node_modules/react-native-svg/lib/extract/extractTransform.js"],"names":["Matrix2D","peg","_","pooledMatrix","transformToMatrix","props","transform","reset","appendTransform","toArray","transformParser","generate","parse","a","c","e","b","d","f","append","console","error","x","originX","y","originY","scaleX","scaleY","rotation","skewX","skewY","universal2axis","universal","axisX","axisY","defaultValue","coords","isString","split","length","isNumber","isNaN","props2transform","origin","scale","skew","translate","isNil","translateX","translateY"],"mappings":"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","sourcesContent":["import Matrix2D from \"../Matrix2D\";\nimport peg from \"pegjs\";\nimport _ from \"lodash\";\n\nconst pooledMatrix = new Matrix2D();\n\nfunction transformToMatrix(props, transform) {\n    pooledMatrix.reset();\n    appendTransform(props);\n\n    if (transform) {\n        appendTransform(transform);\n    }\n\n    return pooledMatrix.toArray();\n}\n\nconst transformParser = peg.generate(`\n{\n    var deg2rad = Math.PI / 180;\n\n    /*\n     ╔═        ═╗   ╔═        ═╗   ╔═     ═╗\n     ║ al cl el ║   ║ ar cr er ║   ║ a c e ║\n     ║ bl dl fl ║ * ║ br dr fr ║ = ║ b d f ║\n     ║ 0  0  1  ║   ║ 0  0  1  ║   ║ 0 0 1 ║\n     ╚═        ═╝   ╚═        ═╝   ╚═     ═╝\n    */\n    function multiply_matrices(l, r) {\n        var [al, cl, el, bl, dl, fl] = l;\n        var [ar, cr, er, br, dr, fr] = r;\n\n        var a = al * ar + cl * br;\n        var c = al * cr + cl * dr;\n        var e = al * er + cl * fr + el;\n        var b = bl * ar + dl * br;\n        var d = bl * cr + dl * dr;\n        var f = bl * er + dl * fr + fl;\n\n        return [a, c, e, b, d, f];\n    }\n}\n\ntransformList\n    = wsp* ts:transforms? wsp* { return ts; }\n\ntransforms\n    = t:transform commaWsp* ts:transforms\n    {\n        return multiply_matrices(t, ts);\n    }\n    / t:transform\n\ntransform\n    = matrix\n    / translate\n    / scale\n    / rotate\n    / skewX\n    / skewY\n\nmatrix\n    = \"matrix\" wsp* \"(\" wsp*\n        a:number commaWsp\n        b:number commaWsp\n        c:number commaWsp\n        d:number commaWsp\n        e:number commaWsp\n        f:number wsp* \")\"\n    {\n        return [\n            a, c, e,\n            b, d, f\n        ];\n    }\n\ntranslate\n    = \"translate\" wsp* \"(\" wsp* tx:number ty:commaWspNumber? wsp* \")\"\n    {\n        return [\n            1, 0, tx,\n            0, 1, ty || 0\n        ];\n    }\n\nscale\n    = \"scale\" wsp* \"(\" wsp* sx:number sy:commaWspNumber? wsp* \")\"\n    {\n        return [\n            sx, 0,                     0,\n            0,  sy === null ? sx : sy, 0\n        ];\n    }\n\nrotate\n    = \"rotate\" wsp* \"(\" wsp* angle:number c:commaWspTwoNumbers? wsp* \")\"\n    {\n        var cos = Math.cos(deg2rad * angle);\n        var sin = Math.sin(deg2rad * angle);\n        if (c !== null) {\n            var [x, y] = c;\n            return [\n                cos, -sin, cos * -x + -sin * -y + x,\n                sin,  cos, sin * -x +  cos * -y + y\n            ];\n        }\n        return [\n            cos, -sin, 0,\n            sin,  cos, 0\n        ];\n    }\n\nskewX\n    = \"skewX\" wsp* \"(\" wsp* angle:number wsp* \")\"\n    {\n        return [\n            1, Math.tan(deg2rad * angle), 0,\n            0, 1,                         0\n        ];\n    }\n\nskewY\n    = \"skewY\" wsp* \"(\" wsp* angle:number wsp* \")\"\n    {\n        return [\n            1,                         0, 0,\n            Math.tan(deg2rad * angle), 1, 0\n        ];\n    }\n\nnumber\n    = f:(sign? floatingPointConstant) { return parseFloat(f.join(\"\")); }\n    / i:(sign? integerConstant) { return parseInt(i.join(\"\")); }\n\ncommaWspNumber\n    = commaWsp n:number { return n; }\n\ncommaWspTwoNumbers\n    = commaWsp n1:number commaWsp n2:number { return [n1, n2]; }\n\ncommaWsp\n    = (wsp+ comma? wsp*) / (comma wsp*)\n\ncomma\n    = \",\"\n\nintegerConstant\n    = ds:digitSequence { return ds.join(\"\"); }\n\nfloatingPointConstant\n    = f:(fractionalConstant exponent?) { return f.join(\"\"); }\n    / d:(digitSequence exponent) { return d.join(\"\"); }\n\nfractionalConstant \"fractionalConstant\"\n    = d1:digitSequence? \".\" d2:digitSequence { return [d1 ? d1.join(\"\") : null, \".\", d2.join(\"\")].join(\"\"); }\n    / d:digitSequence \".\" { return d.join(\"\"); }\n\nexponent\n    =  e:([eE] sign? digitSequence) { return [e[0], e[1], e[2].join(\"\")].join(\"\"); }\n\nsign\n    = [+-]\n\ndigitSequence\n    = digit+\n\ndigit\n    = [0-9]\n\nwsp\n    = [\\\\u0020\\\\u0009\\\\u000D\\\\u000A]\n`);\n\nfunction appendTransform(transform) {\n    if (transform) {\n        if (typeof transform === \"string\") {\n            try {\n                const [a, c, e, b, d, f] = transformParser.parse(transform);\n                pooledMatrix.append(...[a, b, c, d, e, f]);\n            } catch (e) {\n                console.error(e);\n            }\n        } else {\n            pooledMatrix.appendTransform(\n                transform.x + transform.originX,\n                transform.y + transform.originY,\n                transform.scaleX,\n                transform.scaleY,\n                transform.rotation,\n                transform.skewX,\n                transform.skewY,\n                transform.originX,\n                transform.originY,\n            );\n        }\n    }\n}\n\nfunction universal2axis(universal, axisX, axisY, defaultValue) {\n    let coords = [];\n    let x;\n    let y;\n    if (_.isString(universal)) {\n        coords = universal.split(/\\s*,\\s*/);\n        if (coords.length === 2) {\n            x = +coords[0];\n            y = +coords[1];\n        } else if (coords.length === 1) {\n            x = y = +coords[0];\n        }\n    } else if (_.isNumber(universal)) {\n        x = y = universal;\n    }\n\n    axisX = +axisX;\n    if (!isNaN(axisX)) {\n        x = axisX;\n    }\n\n    axisY = +axisY;\n    if (!isNaN(axisY)) {\n        y = axisY;\n    }\n\n    return [x || defaultValue || 0, y || defaultValue || 0];\n}\n\nexport function props2transform(props) {\n    if (props && typeof props === \"string\") {\n        return props;\n    }\n    const [originX, originY] = universal2axis(\n        props.origin,\n        props.originX,\n        props.originY,\n    );\n    const [scaleX, scaleY] = universal2axis(\n        props.scale,\n        props.scaleX,\n        props.scaleY,\n        1,\n    );\n    const [skewX, skewY] = universal2axis(props.skew, props.skewX, props.skewY);\n    const [translateX, translateY] = universal2axis(\n        props.translate,\n        _.isNil(props.translateX) ? props.x || 0 : props.translateX,\n        _.isNil(props.translateY) ? props.y || 0 : props.translateY,\n    );\n\n    return {\n        rotation: +props.rotation || 0,\n        scaleX: scaleX,\n        scaleY: scaleY,\n        originX: originX,\n        originY: originY,\n        skewX: skewX,\n        skewY: skewY,\n        x: translateX,\n        y: translateY,\n    };\n}\n\nexport default function(props) {\n    return transformToMatrix(\n        props2transform(props),\n        props.transform ? props2transform(props.transform) : null,\n    );\n}\n"]},"metadata":{},"sourceType":"module"}